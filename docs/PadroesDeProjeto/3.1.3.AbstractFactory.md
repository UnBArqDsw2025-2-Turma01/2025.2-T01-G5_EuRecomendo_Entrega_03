# 3.1.3. Abstract Factory

## Introdução

O Abstract Factory é um padrão de design criacional que permite criar famílias de objetos relacionados sem especificar a sua classe concreta. Ele é útil quando um sistema precisa ser independente de como seus objetos são criados e representados. Ao usar o Abstract Factory, o sistema é desacoplado da criação dos objetos, permitindo que novas famílias de objetos possam ser introduzidas sem impactar o código que os utiliza.

Ele organiza e abstrai a criação de objetos, criando uma interface comum que permite a criação de objetos de diferentes famílias, enquanto mantém a flexibilidade para a adição de novos tipos de objetos no futuro. A família de objetos pode ser de diferentes tipos ou categorias, como interfaces de usuário, produtos de software, ou até mesmo diferentes configurações de um sistema. Esse padrão é bastante utilizado em frameworks, interfaces de usuário, configurações de sistemas e cenários onde as classes de objetos dependem de variantes ou configurações específicas.

## Metodologia

Para a implementação do padrão Abstract Factory, primeiro se estudou o padrão através das referências citadas ao final dessa página. Em seguida, foi analisado o [Diagrama de Classes do projeto](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G5_EuRecomendo_Entrega_02/#/./Modelagem/2.1.3.DiagramaDeClassesUML) com o intuito de identificar possibilidades de aplicação do padrão. Após isso foi feito a modelagem do diagrama, que serviu de base para a implementação do código. Abaixo estão listadas as ferramentas empregadas e suas respectivas finalidades:

- **Draw.io**: Utilizado para a criação do diagrama que ilustra a estrutura do padrão, facilitando a visualização das relações entre classes e interfaces.
- **Visual Studio Code (VSCode)**: Empregado como ambiente de desenvolvimento integrado (IDE) para a escrita, edição e depuração do código-fonte.
- **YouTube**: Utilizado para gravar e compartilhar vídeos demonstrando o funcionamento do código implementado, permitindo a validação visual dos resultados.
- **Docsify**: Ferramenta usada para o desenvolvimento e geração da documentação do projeto, garantindo uma apresentação clara e acessível do conteúdo.
- **Django**: Framework principal utilizado para o desenvolvimento, estruturando o projeto;
- **Python**: Linguagem de programação adotada.

## Desenvolvimento

O padrão Abstract Factory foi aplicado a criação de usuários, com uma interface genérica chamada UserFactory. Essa fábrica abstrata possui métodos genéricos que criam usuários e recomendações. Enquanto as fábricas concretas implementam métodos de criação da fábrica abstrata específicos daquela variação. A fábrica <b>StandardUserFactory</b> cria usuários padrões e recomendações, e a fábrica StaffUserFactory cria usuários do tipo administradores, que tem privilégios, como editar livros, excluir recomendações impróprias e registrar livros.

<font size="2"><p style="text-align: center">Figura 1 - Diagrama Abstract Factory.</p></font>

<center>

![Imagem](/assets/DiagramaAbstractFactory.png)

</center>

<font size="2"><p style="text-align: center">Autor: [Tiago Antunes](https://github.com/tiagobalieiro), 2025.</p></font>


## Código

Para visualizar o código completo desse padrão de projeto acesse o código na branch [code-abstractFactory](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G5_EuRecomendo_Entrega_03/tree/code-abstractFactory).

## Vídeo

<font size="2"><p style="text-align: center">Vídeo 1 - Código Abstract Factory.</p></font>

<center>
<iframe 
  src="https://drive.google.com/file/d/1JiJP5Z6S_AmHALNgjVF6kzmezbcW5N2W/preview" 
  width="640" 
  height="480" 
  allow="autoplay">
</iframe>
</center>

<font size="2"><p style="text-align: center">Autor: [Tiago Antunes](https://github.com/tiagobalieiro), 2025.</p></font>


## Fábricas

### users.factories.abstractFactory.py

```python
from abc import ABC, abstractmethod
from django.contrib.auth import get_user_model
from books.models import Book, Review

User = get_user_model()

class UserFactory(ABC):
    @abstractmethod
    def create_user(self, data: dict) -> User: ...
    def create_review(self, *, user: User, book: Book, rating: int, text: str = "") -> Review:
        return Review.objects.create(user=user, book=book, rating=rating, text=text)
    def register_book(self, *, title: str, author: str = "", synopsis: str = "") -> Book:
        raise NotImplementedError("Este tipo de usuário não registra livros.")

```

### users.factories.standardUserFactory.py

```python
from django.contrib.auth import get_user_model
from .abstractFactory import UserFactory

User = get_user_model()

class StandardUserFactory(UserFactory):
    def create_user(self, data: dict) -> User:
        user = User(username=data["username"], email=data["email"], is_staff=False, is_superuser=False)
        user.set_password(data["password"])
        user.save()
        return user
```

### users.factories.staffUserFactory.py
```python
from django.contrib.auth import get_user_model
from books.models import Book
from .abstractFactory import UserFactory

User = get_user_model()

class StaffUserFactory(UserFactory):
    def create_user(self, data: dict) -> User:
        user = User(username=data["username"], email=data["email"], is_staff=True, is_superuser=True)
        user.set_password(data["password"])
        user.save()
        return user
    def register_book(self, *, title: str, author: str = "", synopsis: str = "") -> Book:
        return Book.objects.create(title=title, author=author, synopsis=synopsis)

```

## Conclusão

A aplicação do padrão Abstract Factory no projeto permitiu estruturar de forma clara e escalável o processo de criação de diferentes tipos de usuários e seus objetos relacionados, como livros e avaliações. Com esse padrão, o sistema ficou mais flexível e desacoplado, tornando a manutenção e a adição de novos perfis de usuário mais fácil, sem alterar o código existente. Isso reforça a separação de responsabilidades e contribui para uma arquitetura mais organizada e escalável.

## Bibliografia

> [1] Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1995). _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley.

> [2] Refactoring Guru. (s.d.). _Factory Method_. Disponível em: <https://refactoring.guru/design-patterns/abstract-factory>.


### Histórico de Versões

| Versão | Data       | Descrição                                                                    | Autor(es)                                                                                        | Revisor(es)                                   | Detalhes da Revisão |
| ------ | ---------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | --------------------------------------------- | ------------------- |
| 1.0    | 21/10/2025 | Criação inicial do documento                      | [Tiago Antunes](https://github.com/tiagobalieiro) | [Bruno Bragança](https://github.com/BrunoBReis) |                     |
|1.1    | 23/10/2025 | Adição da documentação, do diagrama e do código   | [Tiago Antunes](https://github.com/tiagobalieiro) | [Bruno Bragança](https://github.com/BrunoBReis) |                     |
