# 3.2.3. Proxy

## Introdução

O Proxy é um padrão de design estrutural que permite criar um substituto pra um outro objeto qualquer. Esse substituto então passa a controlar o acesso ao objeto original e abre uma série de possibilidade, como executar alguma coisa antes ou depois do pedido chegar ao objeto original, ou armazenar resultados em cache, melhorando a perfomance e o custo.

## Metodologia

Para a implementação do padrão Proxy, primeiro se estudou o padrão através das referências citadas ao final dessa página. Em seguida, foi analisado o [Diagrama de Classes do projeto](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G5_EuRecomendo_Entrega_02/#/./Modelagem/2.1.3.DiagramaDeClassesUML) com o intuito de identificar possibilidades de aplicação do padrão. Após isso foi feito a modelagem do diagrama, que serviu de base para a implementação do código. Abaixo estão listadas as ferramentas empregadas e suas respectivas finalidades:

- **Draw.io**: Utilizado para a criação do diagrama que ilustra a estrutura do padrão, facilitando a visualização das relações entre classes e interfaces.
- **Visual Studio Code (VSCode)**: Empregado como ambiente de desenvolvimento integrado (IDE) para a escrita, edição e depuração do código-fonte.
- **YouTube**: Utilizado para gravar e compartilhar vídeos demonstrando o funcionamento do código implementado, permitindo a validação visual dos resultados.
- **Docsify**: Ferramenta usada para o desenvolvimento e geração da documentação do projeto, garantindo uma apresentação clara e acessível do conteúdo.
- **Django**: Framework principal utilizado para o desenvolvimento, estruturando o projeto;
- **Python**: Linguagem de programação adotada.

## Desenvolvimento

O padrão Proxy foi aplicado ao acesso ao banco de usuários pela classe <b>RecommendationService</b>, que busca informações do usuário através de um userId pelo método público getProfile(). Essa classe é a responsável por fazer recomendações e para isso necessita de informações como o histórico, avaliações e gêneros de preferência. Como ela deve acessar o banco de usuários a cada recomendação, é uma candidata perfeita para a aplicação do padrão Proxy.

O proxy intercepta as chamadas para adicionar cache, evitando acessos desnecessários e melhorando a perfomance. O cliente interage com a interface UserRepository, que define a principal operação de buscar perfil de usuário. O profileService é a classe concreta, que faz a consulta aos dados. A classe cachedProfileProxy é a parte principal desse padrão, pois permite que o cliente interaja com ela como um substituo a classe concreta profileService.

<font size="2"><p style="text-align: center">Figura 1 - Diagrama Proxy.</p></font>

<center>

![Imagem](/assets/DiagramaProxy.png)

</center>

<font size="2"><p style="text-align: center">Autor: [Tiago Antunes](https://github.com/tiagobalieiro), 2025.</p></font>


## Código

Para visualizar o código completo desse padrão de projeto acesse o código na branch [code-abstractFactory](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G5_EuRecomendo_Entrega_03/tree/code-abstractFactory).

## Vídeo

<font size="2"><p style="text-align: center">Vídeo 1 - Código Abstract Factory.</p></font>

<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</center>

<font size="2"><p style="text-align: center">Autor: [Tiago Antunes](https://github.com/tiagobalieiro), 2025.</p></font>

## ProfileService

```python
class ProfileService(UserRepository):
    def get_profile(self, user_id: int) -> Optional[ProfileDict]:
        logger.info("DB_HIT get_profile user_id=%s", user_id)  # <-- prova do acesso ao banco
        User = get_user_model()
        try:
            u = User.objects.only("id","username","email","first_name","last_name").get(pk=user_id)
        except User.DoesNotExist:
            return None
        return ProfileDict(
            id=u.id,
            username=u.username,
            email=u.email or "",
            first_name=u.first_name or "",
            last_name=u.last_name or "",
        )

```

## cachedProfileProxy

```python
class CachedProfileProxy(UserRepository):
    def __init__(self, real: UserRepository, ttl_seconds: int = 900):
        self._real = real
        self._ttl = ttl_seconds

    def _key(self, user_id: int) -> str:
        return f"user:{user_id}:profile"

    def get_profile(self, user_id: int) -> ProfileDict | None:
        key = self._key(user_id)
        hit = cache.get(key)
        if hit is not None:
            logger.info("HIT key=%s", key)
            return hit
        logger.info("MISS key=%s", key)
        result = self._real.get_profile(user_id)
        if result is not None:
            cache.set(key, result, timeout=self._ttl)
        return result
```

## userRepository

```python
class ProfileDict(TypedDict, total=False):
    id: int
    username: str
    email: str
    first_name: str
    last_name: str

class UserRepository(Protocol):
    def get_profile(self, user_id: int) -> Optional[ProfileDict]: ...

```

## Conclusão

A aplicação do padrão Proxy no projeto permitiu otimizar o acesso às informações de usuários, reduzindo consultas redundantes ao banco de dados por meio de um mecanismo de cache inteligente. Isso melhora significativamente a performance e a escalabilidade do sistema, mantendo o mesmo contrato de acesso e separando claramente as responsabilidades entre a lógica de negócio e a de otimização.

## Bibliografia

> [1] Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1995). _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley.

> [2] Refactoring Guru. (s.d.). _Proxy_. Disponível em: <https://refactoring.guru/design-patterns/proxy>.


### Histórico de Versões

| Versão | Data       | Descrição                                                                    | Autor(es)                                                                                        | Revisor(es)                                   | Detalhes da Revisão |
| ------ | ---------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | --------------------------------------------- | ------------------- |
| 1.0    | 21/10/2025 | Criação inicial do documento                      | [Tiago Antunes](https://github.com/tiagobalieiro) | [Bruno Bragança](https://github.com/BrunoBReis) |   
| 1.1   | 23/10/2025 | Adição da documentação, do diagrama e do código   | [Tiago Antunes](https://github.com/tiagobalieiro) | [Bruno Bragança](https://github.com/BrunoBReis) |                     |
