# 3.1.5. Prototype

## Introdução

O Prototype é um padrão criacional GoF que permite criar novos objetos copiando instâncias existentes (protótipos), sem tornar o código dependente de suas classes concretas. Na aplicação "EuRecomendo", aplicamos este padrão para:

**Aplicação Principal:** Permitir que usuários clonem listas de leitura completas de outros usuários, criando cópias independentes com todos os livros associados, facilitando o compartilhamento e personalização de recomendações literárias.

Vale ressaltar que o padrão Prototype é normalmente usado quando:

- Você precisa criar cópias de objetos sem depender de suas classes concretas
- O custo de criar um novo objeto do zero é maior que clonar um existente
- Deseja evitar hierarquias de fábricas paralelas às hierarquias de produtos
- Precisa isolar o código cliente dos detalhes de implementação dos objetos
- Necessita criar objetos configurados de formas específicas de maneira eficiente
- Quer reduzir o número de subclasses necessárias apenas para inicialização

## Objetivo

Para a nossa aplicação do padrão no EuRecomendo:

- Permitir clonagem de listas de leitura entre usuários
- Criar cópias independentes mantendo a estrutura original
- Facilitar compartilhamento de recomendações literárias
- Evitar recriação manual de listas com muitos livros
- Personalizar listas clonadas sem afetar o original
- Reduzir acoplamento entre código cliente e classes concretas

## Vantagens

- **Independência de classes concretas:** Cliente não precisa conhecer classes específicas
- **Redução de subclasses:** Elimina necessidade de fábricas complexas
- **Configuração dinâmica:** Adiciona/remove objetos em tempo de execução
- **Performance:** Clonagem geralmente é mais rápida que criação do zero
- **Flexibilidade:** Permite criar variações complexas facilmente
- **Encapsulamento:** Oculta complexidade de criação de objetos

## Desvantagens

- **Complexidade de clonagem profunda:** Objetos com referências circulares são difíceis de clonar
- **Implementação trabalhosa:** Cada classe precisa implementar método de clonagem
- **Dependências ocultas:** Clones podem compartilhar referências inesperadamente
- **Violação de encapsulamento:** Clonagem pode expor detalhes internos
- **Gerenciamento de estado:** Difícil garantir estado consistente após clonagem
- **Overhead de manutenção:** Cada modificação na classe requer atualização do clone

## Metodologia

Para a realização deste projeto, adotamos uma abordagem estruturada:

**Ferramentas:**
- VS Code para desenvolvimento
- Django/DRF para implementação do backend
- PostgreSQL para persistência
- Docker para containerização
- pytest/Django TestCase para testes
- Postman para testes de API

**Processo de Desenvolvimento:**
1. Estudo aprofundado do padrão Prototype através das referências bibliográficas
2. Análise dos requisitos do EuRecomendo para identificar entidades clonáveis
3. Modelagem da estrutura: ReadingList como protótipo clonável
4. Implementação do método `clone_for_user()` no model
5. Criação de endpoint REST para clonagem via API
6. Validação através de casos de uso reais
7. Documentação técnica detalhada

**Referências:**
- Gamma, E. et al. **Design Patterns: Elements of Reusable Object-Oriented Software**. Addison-Wesley, 1995.
- Refactoring Guru - Prototype Pattern: https://refactoring.guru/design-patterns/prototype
- Python Design Patterns: https://python-patterns.guide/gang-of-four/prototype/
- Django Documentation: https://docs.djangoproject.com/
- GeeksforGeeks - Prototype Pattern: https://www.geeksforgeeks.org/prototype-method-python-design-patterns/

O desenvolvimento seguiu abordagem iterativa, começando com estudo teórico profundo do padrão, seguido por análise do domínio do problema, modelagem de dados, implementação com testes, e documentação contínua dos aprendizados.

## Aplicação no EuRecomendo

### Código

#### Model ReadingList com Prototype (backend/library/models.py)

Model Django que implementa o padrão Prototype através do método `clone_for_user()`:

```python
from django.db import models
from users.models import UserProfile
from books.models import Book
import copy

class ReadingList(models.Model):
    owner = models.ForeignKey(UserProfile, on_delete=models.CASCADE, related_name='reading_lists')
    name = models.CharField(max_length=255)
    books = models.ManyToManyField('books.Book', related_name='in_reading_lists')

    def clone_for_user(self, new_owner):
        """
        Create a copy of this reading list for a new user.
        Implementa o padrão Prototype.
        """
        # 1. Create new ReadingList instance
        cloned_list = ReadingList.objects.create(
            owner=new_owner,
            name=f"{self.name} (cloned)"
        )

        # 2. Copy all books
        cloned_list.books.set(self.books.all())

        return cloned_list

    def __str__(self):
        return self.name
```

**Autores:** Henrique Quenino e Iago Rocha, 2025

#### Serializer (backend/library/serializers.py)

Serializer para expor a API REST:

```python
from rest_framework import serializers
from .models import ReadingList

class ReadingListSerializer(serializers.ModelSerializer):
    class Meta:
        model = ReadingList
        fields = ['id', 'name', 'owner', 'books']
```

**Autores:** Henrique Quenino e Iago Rocha, 2025

#### ViewSet com Clone Action (backend/library/views.py)

ViewSet que expõe o endpoint de clonagem:

```python
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from .models import ReadingList
from .serializers import ReadingListSerializer
from users.models import UserProfile

class ReadingListViewSet(viewsets.ModelViewSet):
    queryset = ReadingList.objects.all()
    serializer_class = ReadingListSerializer

    @action(detail=False, methods=['get'], url_path='by-user/(?P<user_id>[^/.]+)')
    def by_user(self, request, user_id=None):
        """
        GET /api/reading-lists/by-user/{user_id}/
        Returns all reading lists for a specific user.
        """
        try:
            user = UserProfile.objects.get(pk=user_id)
        except UserProfile.DoesNotExist:
            return Response({"error": "User not found"}, status=status.HTTP_404_NOT_FOUND)

        reading_lists = ReadingList.objects.filter(owner=user)
        serializer = self.get_serializer(reading_lists, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

    @action(detail=True, methods=['post'])
    def clone(self, request, pk=None):
        """
        POST /api/reading-lists/{id}/clone/
        Clona uma lista de leitura para um novo usuário.
        Implementa o padrão Prototype via API REST.
        """
        reading_list = self.get_object()
        new_owner_id = request.data.get('new_owner_id')
        
        try:
            new_owner = UserProfile.objects.get(pk=new_owner_id)
        except UserProfile.DoesNotExist:
            return Response({"error": "User not found"}, status=status.HTTP_404_NOT_FOUND)

        cloned_list = reading_list.clone_for_user(new_owner)
        serializer = self.get_serializer(cloned_list)
        return Response(serializer.data, status=status.HTTP_201_CREATED)
```

**Autores:** Henrique Quenino e Iago Rocha, 2025

#### URLs Configuration (backend/library/urls.py)

Configuração de rotas da API:

```python
from rest_framework import routers
from .views import ReadingListViewSet
from django.urls import path, include

router = routers.DefaultRouter()
router.register(r'reading-lists', ReadingListViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
```

**Autores:** Henrique Quenino e Iago Rocha, 2025

#### Admin Configuration (backend/library/admin.py)

Configuração do Django Admin:

```python
from django.contrib import admin
from .models import ReadingList

class ReadListAdmin(admin.ModelAdmin):
    list_display = ('id', 'name', 'owner', 'books_list')

    def books_list(self, obj):
        # Make sure to access 'title' or your actual Book field
        return ", ".join([book.title for book in obj.books.all()]) or "—"

    books_list.short_description = "Books"

admin.site.register(ReadingList, ReadListAdmin)
```

**Autores:** Henrique Quenino e Iago Rocha, 2025

### Resultados do Código

#### Exemplo 1: Criar Lista de Leitura

**Request:**
```bash
POST /api/reading-lists/
Content-Type: application/json

{
  "name": "Ficção Científica Clássica",
  "owner": 1,
  "books": [1, 2, 3]
}
```

**Response: 201 CREATED**
```json
{
  "id": 1,
  "name": "Ficção Científica Clássica",
  "owner": 1,
  "books": [1, 2, 3]
}
```

#### Exemplo 2: Clonar Lista de Leitura

**Request:**
```bash
POST /api/reading-lists/1/clone/
Content-Type: application/json

{
  "new_owner_id": 2
}
```

**Response: 201 CREATED**
```json
{
  "id": 2,
  "name": "Ficção Científica Clássica (cloned)",
  "owner": 2,
  "books": [1, 2, 3]
}
```

#### Exemplo 3: Listar Listas por Usuário

**Request:**
```bash
GET /api/reading-lists/by-user/1/
```

**Response: 200 OK**
```json
[
  {
    "id": 1,
    "name": "Ficção Científica Clássica",
    "owner": 1,
    "books": [1, 2, 3]
  },
  {
    "id": 3,
    "name": "Fantasia Épica",
    "owner": 1,
    "books": [4, 5, 6, 7]
  }
]
```


### Passo a Passo para Rodar os Códigos

#### 1. Configurar ambiente Docker

```bash
cd backend
docker compose up --build -d
```

Verificar containers:
```bash
docker compose ps
```

#### 2. Aplicar migrações do banco de dados

```bash
# Criar migrações
docker compose exec web python manage.py makemigrations library users books

# Aplicar migrações
docker compose exec web python manage.py migrate
```

#### 3. Criar superusuário

```bash
docker compose exec web python manage.py createsuperuser
```

Exemplo:
- Username: `admin`
- Email: `admin@example.com`
- Password: `admin123`

#### 4. Criar livros de teste

```bash
curl -X POST http://localhost:8001/api/books/ \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Neuromancer",
    "author": "William Gibson"
  }'

curl -X POST http://localhost:8001/api/books/ \
  -H "Content-Type: application/json" \
  -d '{
    "title": "Fundação",
    "author": "Isaac Asimov"
  }'

curl -X POST http://localhost:8001/api/books/ \
  -H "Content-Type: application/json" \
  -d '{
    "title": "1984",
    "author": "George Orwell"
  }'
```

#### 5. Criar lista de leitura

```bash
curl -X POST http://localhost:8001/api/reading-lists/ \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ficção Científica Clássica",
    "owner": 1,
    "books": [1, 2, 3]
  }'
```

#### 6. Clonar lista de leitura

```bash
curl -X POST http://localhost:8001/api/reading-lists/1/clone/ \
  -H "Content-Type: application/json" \
  -d '{
    "new_owner_id": 2
  }'
```
### Vídeo

**Vídeo 1 - Prototype Pattern no EuRecomendo**

[Link do YouTube](https://youtu.be/8vww5XEmLRQ)

**Autor/es:** Henrique Quenino e Iago Rocha, 2025

## Bibliografia

- Gamma, E. et al. **Design Patterns: Elements of Reusable Object-Oriented Software**. Addison-Wesley, 1995.
- Refactoring Guru - Prototype Pattern: https://refactoring.guru/design-patterns/prototype
- Python Design Patterns - Prototype: https://python-patterns.guide/gang-of-four/prototype/
- GeeksforGeeks - Prototype Pattern: https://www.geeksforgeeks.org/prototype-method-python-design-patterns/
- Wikipedia - Prototype Pattern: https://en.wikipedia.org/wiki/Prototype_pattern
- Django REST Framework: https://www.django-rest-framework.org/
- Django Documentation: https://docs.djangoproject.com/

## Histórico de Versões

| Versão | Data | Descrição | Autor(es) |
|--------|------|-----------|-----------|
| 0.1 | 24/10/2025 | Criação inicial do documento | Henrique Quenino e Iago Rocha |
| 0.2 | 24/10/2025 | Adição de código completo e exemplos de uso | Henrique Quenino e Iago Rocha |
| 1.0 | 24/10/2025 | Versão final com todos os componentes implementados | Henrique Quenino e Iago Rocha |