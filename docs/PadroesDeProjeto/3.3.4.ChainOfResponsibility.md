# 3.3.4. Chain Of Responsibility

## Introdução

O Chain of Responsibility é um padrão de design comportamental que permite desacoplar quem emite uma solicitação de quem a processa, encaminhando-a por uma cadeia de manipuladores (handlers) até que um deles a trate, ou cada um a processe. Ele é útil quando um sistema precisa aplicar regras variadas e evolutivas sem fixar, no cliente, qual componente executará cada regra. Ao usar Chain, a ordem e a presença dos handlers podem ser alteradas sem impactar o código que dispara a solicitação, facilitando a extensibilidade e a manutenção.

Ele organiza e abstrai o processamento dividindo-o em etapas independentes, onde cada handler decide se trata, transforma, sinaliza ou repassa a solicitação ao próximo. Isso permite montar pipelines de validação, moderação e auditoria, com possibilidade de interrupção precoce ou acúmulo de resultados para decisão ao final. O padrão é amplamente utilizado em validações de entrada, moderação de conteúdo, autorização, middleware HTTP, logging e processamento de eventos. No contexto educacional de moderação de reviews, ele viabiliza encadear regras de forma clara, testável e facilmente extensível.

## Metodologia

Para a implementação do padrão Chain of Responsibility, primeiro se estudou o padrão através das referências citadas ao final dessa página. Em seguida, foi analisado o [Diagrama de Classes do projeto](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G5_EuRecomendo_Entrega_02/#/./Modelagem/2.1.3.DiagramaDeClassesUML) com o intuito de identificar possibilidades de aplicação do padrão. Após isso foi feito a modelagem do diagrama, que serviu de base para a implementação do código. Abaixo estão listadas as ferramentas empregadas e suas respectivas finalidades:

- **Draw.io**: Utilizado para a criação do diagrama que ilustra a estrutura do padrão, facilitando a visualização das relações entre classes e interfaces.
- **Visual Studio Code (VSCode)**: Empregado como ambiente de desenvolvimento integrado (IDE) para a escrita, edição e depuração do código-fonte.
- **YouTube**: Utilizado para gravar e compartilhar vídeos demonstrando o funcionamento do código implementado, permitindo a validação visual dos resultados.
- **Docsify**: Ferramenta usada para o desenvolvimento e geração da documentação do projeto, garantindo uma apresentação clara e acessível do conteúdo.
- **Django**: Framework principal utilizado para o desenvolvimento, estruturando o projeto;
- **Python**: Linguagem de programação adotada.

## Desenvolvimento

O padrão Chain of Responsibility foi aplicado à moderação/validação de reviews, definindo uma interface genérica Handler e uma cadeia de processos. Cada manipulador implementa um handle e decide se trata e encaminha ao próximo ou interrompe o fluxo em caso de erro grave. No diagrama, foi se encadeado os handlers concretos <b>RequiredFieldsHandler</b>, <b>LengthHandler</b>, <b>ProfanityHandler</b> e <b>DuplicateHandler</b>. O <b>ReviewService</b> cria a cadeia e envia um ReviewContext (user, book, rating, text); violações “hard” causam um curti circuito (por exemplo, rating fora de 1..5 ou profanidade severa). Assim, novas regras entram por adição/reordenação de handlers, mantendo o cliente desacoplado da lógica de moderação.

<font size="2"><p style="text-align: center">Figura 1 - Diagrama Chain of Responsibility.</p></font>

<center>

![Imagem](/assets/DiagramaChain.png)

</center>

<font size="2"><p style="text-align: center">Autor: [Tiago Antunes](https://github.com/tiagobalieiro), 2025.</p></font>


## Código

Para visualizar o código completo desse padrão de projeto acesse o código na branch [code-chain](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G5_EuRecomendo_Entrega_03/tree/code-chain).

## Vídeo

<font size="2"><p style="text-align: center">Vídeo 1 - Código Chain.</p></font>

<center>
<iframe 
  src="https://drive.google.com/file/d/10k-ulWcbMhkVto3uECHvlPt1aAj22-BD/preview" 
  width="640" 
  height="480" 
  allow="autoplay">
</iframe>
</center>

<font size="2"><p style="text-align: center">Autor: [Tiago Antunes](https://github.com/tiagobalieiro), 2025.</p></font>

## AbstractHandler (interface)

```python
class AbstractHandler(Handler):
    _next: Optional[Handler] = None

    def set_next(self, nxt: Handler) -> Handler:
        self._next = nxt
        return nxt

    def handle(self, ctx: ReviewContext) -> ModerationResult:
        self.do_handle(ctx)
        if any(True for _ in ctx.errors):  
            pass
        if self._next:
            return self._next.handle(ctx)
        if ctx.errors:
            return ModerationResult(status=Status.REJECTED, errors=ctx.errors, final_text=ctx.sanitized_text or ctx.text)
        return ModerationResult(status=Status.APPROVED, errors=[], final_text=ctx.sanitized_text or ctx.text)

    def do_handle(self, ctx: ReviewContext) -> None:
        return
```

## RequiredFieldHandler

```python
class RequiredFieldsHandler(AbstractHandler):
    def do_handle(self, ctx: ReviewContext) -> None:
        if not ctx.book_title:
            ctx.errors.append(RuleViolation("MISSING_BOOK", "O título do livro é obrigatório."))
        if ctx.rating is None:
            ctx.errors.append(RuleViolation("MISSING_RATING", "A nota (rating) é obrigatória."))
        if ctx.text is None or not str(ctx.text).strip():
            ctx.errors.append(RuleViolation("MISSING_TEXT", "O texto da review é obrigatório."))
```

## LenghtHandler

```python
class LengthHandler(AbstractHandler):
    def __init__(self, min_chars: int = 5, max_chars: int = 1000):
        self.min = min_chars
        self.max = max_chars

    def do_handle(self, ctx: ReviewContext) -> None:
        if ctx.text is None:
            return
        t = ctx.text.strip()
        if len(t) < self.min:
            ctx.errors.append(RuleViolation("TEXT_TOO_SHORT", f"O texto deve ter ao menos {self.min} caracteres."))
        if len(t) > self.max:
            ctx.errors.append(RuleViolation("TEXT_TOO_LONG", f"O texto deve ter no máximo {self.max} caracteres."))
```

## ProfanityHandler

```python
class ProfanityHandler(AbstractHandler):
    def __init__(self, deny_list: Optional[List[str]] = None):
        self.deny_list = [w.lower() for w in (deny_list or ["idiota", "imbecil", "palavrao"])]

    def do_handle(self, ctx: ReviewContext) -> None:
        if not ctx.text:
            return
        lowered = ctx.text.lower()
        if any(bad in lowered for bad in self.deny_list):
            ctx.errors.append(RuleViolation("PROFANITY", "Seu texto contém linguagem imprópria."))
```

## DuplicateHandler

```python
class DuplicateHandler(AbstractHandler):
    """Considera duplicado se o mesmo usuário já avaliou o mesmo livro."""
    def do_handle(self, ctx: ReviewContext) -> None:
        if ctx.user_id and ctx.book_title:
            exists = Review.objects.filter(user_id=ctx.user_id, book_title=ctx.book_title).exists()
            if exists:
                ctx.errors.append(RuleViolation("DUPLICATE", "Você já realizou uma review para este livro."))
```


## Conclusão

A aplicação do padrão Chain of Responsibility no projeto estruturou, de forma clara e escalável, o processo de moderação e validação de reviews por meio de um pipeline de handlers independentes. Com o encadeamento, o cliente permanece desacoplado das regras, permitindo inserir, remover ou reordenar políticas sem alterar o código que dispara a moderação. Isso simplifica a manutenção, facilita a evolução das regras (incluindo interrupção precoce para erros graves) e reforça a separação de responsabilidades, contribuindo para uma arquitetura mais organizada e testável.



## Bibliografia

> [1] Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1995). _Design Patterns: Elements of Reusable Object-Oriented Software_. Addison-Wesley.

> [2] Refactoring Guru. (s.d.). _Chain of Responsibility_. Disponível em: <https://refactoring.guru/design-patterns/chain-of-responsibility>.


### Histórico de Versões

| Versão | Data       | Descrição                                                                    | Autor(es)                                                                                        | Revisor(es)                                   | Detalhes da Revisão |
| ------ | ---------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ | --------------------------------------------- | ------------------- |
| 1.0    | 21/10/2025 | Criação inicial do documento                      | [Tiago Antunes](https://github.com/tiagobalieiro) | [Bruno Bragança](https://github.com/BrunoBReis) |                     |
| 1.1    | 23/10/2025 | Adição da documentação, do diagrama e do código   | [Tiago Antunes](https://github.com/tiagobalieiro) | [Bruno Bragança](https://github.com/BrunoBReis) |  
